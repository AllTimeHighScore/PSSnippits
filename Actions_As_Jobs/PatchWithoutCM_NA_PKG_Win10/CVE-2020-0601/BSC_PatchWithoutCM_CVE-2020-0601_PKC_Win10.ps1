<#
.SYNOPSIS
    Use the WinRM\WMI Process\PsExec run methods to install MS Patches for CVE-2020-0601 on Windows 10
.DESCRIPTION
    Use the WinRM\WMI Process\PsExec run methods to install MS Patches for CVE-2020-0601 on Windows 10
     - This is tailored a little more to reflect the requirements of MFG and other validated systems. - maybe not...
.EXAMPLE
    PS CM2:\> powershell.exe -executionpolicy bypass -file "C:\Temp\SPECIAL_PatchWithoutCM_CVE20191181_PKG_Win10.ps1" -verbose
.INPUTS
    string[]
.OUTPUTS
    LogFile
.NOTES

    A warning for modifications. Adding any additional Invoke-command scriptblocks must be done so carefully. 
    They will dirty the output and make reading the results very difficult unless the results are recast in some way. 
    It will put the job number, runspace ID and some other unwanted metrics in all logs. It makes the JSON almost unreadable

    ========== HISTORY ==========
    Author: Van Bogart, Kevin
    Created: 2020-02-04 12:32:26Z

    Created for reporting on the state of various managed clients that don't have a CM client reporint in.

    ***You must have access to the target devices to run this***

    The PS Custom Object should be the only thing needed.

    Utilizes a Run as Jobs wrapper a coworker <Shawn Leehane> built
        Can target a large amount for devices in short order.
#>

#Start-Transcript -Path "C:\temp\Lists\Inspection_Transcript_$((Get-Date).ToString("yyyymmddhhmmss")).log" -Append -Force
#$VerbosePreference='continue'

#region - Add functions
    function Send-WSMMessage {
        Param(
            [Parameter(Mandatory=$true)]
            [string]$Message,
            [string]$Title = 'Info',
            [ValidateSet('Stop', 'Warning', 'Question','None','Information','Hand','Exclamation','Error','Asterisk')]
            [string]$Icon = 'None'
        )
        process {
            [void] [System.Reflection.Assembly]::LoadWithPartialName("System.Drawing") 
            [void] [System.Reflection.Assembly]::LoadWithPartialName("System.Windows.Forms") 

            [System.Windows.Forms.MessageBox]::show(
                $Message,
                $Title,
                [System.Windows.Forms.MessageBoxButtons]::OKCancel,
                [System.Windows.Forms.MessageBoxIcon]::$Icon
            )
        }
    } # function Send-WSMMessage {

        function Get-WSMFile {   
            Param(
                [string]$InitialDir = "$env:SystemDrive\",
                [string]$FileFilter = 'All files (*.*)|*.*',
                [string]$Title = "Select File"
            )
            process {
                #Customize properties
                [void] [System.Reflection.Assembly]::LoadWithPartialName("System.Drawing")
                [void] [System.Reflection.Assembly]::LoadWithPartialName("System.Windows.Forms")

                $FileBrowser = New-Object -TypeName System.Windows.Forms.OpenFileDialog
                $FileBrowser.initialDirectory = $InitialDir
                $FileBrowser.Filter = $FileFilter
                $FileBrowser.Title = $Title

                #Open form        
                [void]$FileBrowser.ShowDialog()

                #Return selection
                $FileBrowser.FileName    
            }

        } #function Get-WSMFile {
#endregion - Add functions

# Create an output var to store completed job date
$Output = @()

# Creatte a Run ID for this execution space
$JobName = ([guid]::newGuid().Guid).Split('-')[0]

$Domain = 'DC=contoso,DC=com'

# Set a log file here, if we want one
$LogFile = $null

# Set the max number of concurrent jobs
$MaxConcurrentJobs = 30

# Set the max number of hours we want each job to run before we give up and kill it
$MaxRunHours = 5

#logFile
$PostOutFile = "$PSScriptRoot\CVE-2020-0601_Patch_$((Get-Date).ToString("yyyymmddhhmmss")).log"

#Json - For easier parcing
$PostOutJson = "$PSScriptRoot\CVE-2020-0601_Patch_Results_$((Get-Date).ToString("yyyymmddhhmmss")).JSON"

#this is almost pointless.
$PostOutCSV = "$PSScriptRoot\CVE-2020-0601_Patch_Results_$((Get-Date).ToString("yyyymmddhhmmss")).csv"

#Device list
#region - select files

    #Create splat parameters
    $SplatFileSelect = @{
        InitialDir = $PSScriptRoot
        FileFilter = 'Text files (*.txt)|*.txt|All files (*.*)|*.*"'
        Title = 'Select List of Target Devices'
    }

    $TargetSource = Get-WSMFile @SplatFileSelect

    if ( (Get-Item -Path $TargetSource -ErrorAction SilentlyContinue).Exists -eq $true ){
        $PCList = Get-content -Path $TargetSource
    }
    else {
        Send-WSMMessage -Message "A valid file must be selected. In order to target devices for patching. Script exiting!!!"
        Exit
    }

    #Import JSON Config file.
    $JSON = Join-path -Path $PSScriptRoot -ChildPath 'Patches.json'
    if ((Get-Item -Path $JSON -ErrorAction SilentlyContinue).Exists -eq $false){
        Send-WSMMessage -Message "The JSON file is not in the script root. Please select a valid JSON to run this patch script."

        #Create splat parameters
        $SplatJSONSelect = @{
            InitialDir = $PSScriptRoot
            FileFilter = 'JSON files (*.json)|*.json'
            Title = "Select a 'Valid' JSON File"
        }

        $JSON = Get-WSMFile @SplatJSONSelect
    } # if (!(Get-Item -Path $JSON -ErrorAction SilentlyContinue).Exists -eq $true){

    if ((Get-Item -Path $JSON -ErrorAction SilentlyContinue).Exists -eq $false){
        Send-WSMMessage -Message "A valid JSON file must be selected to run this patch script. Script exiting!!!"
        Exit
    }

#endregion - select files

#Other Vars
try {
    $JSONContent = Get-Content -Path $JSON -ErrorAction Stop | ConvertFrom-Json
}
catch {
    Send-WSMMessage -Message "The JSON file content could not be read. Correct the issue and try again. Script exiting!!!"
    Exit
}

#Publicly accessible store for the KBs to be accessed by the script
$PublicSource = $JSONContent.PublicSource

$TargetOSObj = $JSONContent.TargetOSObj

$TargetPatches = $JSONContent.Patches

$Prereqs = $JSONContent.Prereqs

$Media = "$PSScriptRoot\Media"

#I could allow the person to select the appropriate file if it's missing, but I have to draw the line somewhere. Maybe if I end up with a lot of time on my hands.
$AllPatcheCheck = $Prereqs
$AllPatcheCheck += $TargetPatches
$AllPatcheCheck | ForEach-Object {
    #Check if the specified patches are all actually in the local repository
    if ( !(Test-Path -Path "$Media\$($_.Build)\$($_.MSUFile)") ){
        Send-WSMMessage -Message "Missing KB $($_.MSUFile) in local repository: $("$Media\$($_.Build)"). Script exiting!!!"
        Exit
    }
} # $JSONContent.Patches | ForEach-Object {...}

$AllPatcheCheck | ForEach-Object {
    #Check if the specified patches are all actually in the local repository
    if ( !(Test-Path -Path "$PublicSource\$($_.Build)\$($_.MSUFile)") ){
        Send-WSMMessage -Message "Missing KB $($_.MSUFile) in network repository: $("$PublicSource\$($_.Build)").`r`nThe script will be forced to default to the local repo potentially causing poor performance for all devices involved"
    }
} # $JSONContent.Patches | ForEach-Object {...}

#for offline use. and is only really good if it's kept up to date.
$KBCheck = $JSONContent.SupersededKBs

$KBCheck += $TargetPatches.kb # can't join the single and the array at the same time because it will trip when they're joined with a delimiter
# - This web request to gather supersedence is based on a solution Fadyk provided ; much appreciated.
# - The file check had issues because some of the files could be from previous updates and could also 
# - be a leftover if the patch had to be uninstalled previously, Microsoft's uninstallers are messy.
try {
    $KBCheck += $TargetPatches.ID | ForEach-Object {
        $HTML = New-Object -ComObject 'HTMLFile' # Need to redefine each time to ensure it's picking up something new.
        $URL = "https://www.catalog.update.microsoft.com/ScopedViewInline.aspx?updateid=$_"
        $Source = (Invoke-WebRequest -URI $URL -UseBasicParsing).Content
        try {
            $HTML.IHTMLDocument2_Write($Source)
        }
        catch {
            $Source = [System.Text.Encoding]::Unicode.GetBytes($Source)
            $HTML.write($Source)
        }
        (($HTML.getElementById('supersededbyInfo')).InnerText).split(")|(") | Select-String -Pattern 'KB\d+'
    } # $KBCheck += $TargetPatches.ID | ForEach-Object {
}
catch {
    "Failed to get data regarding updates from MS patch site: $($_.Exception.Gettype().fullname)"
    Write-Warning -Message "$($_.Exception.message)"
}

$KBCheck = $KBCheck | Select-Object -Unique
$KBCheck = $KBCheck -join '|'

#region - Log header - remove if you don't need it
@"
"****************************************"
"Running Script $($MyInvocation.mycommand.name) $((Get-Date).ToString("MM/dd/yyyy"))"
"Time $((Get-Date).ToString("HH:mm:ss"))"
"Computer name = $($env:COMPUTERNAME)"
"Invoking User = $($env:USERNAME)"
"****************************************"
"@ -split "`n"  | Out-File -FilePath $PostOutFile -Append -Force
#endregion - Log header - remove if you don't need it
"The Patch Check consists of patches included in the script along with ones listed as superseding them by Microsoft" | Out-File -FilePath $PostOutFile -Append -Force
"Pre-ScriptBlock: Primary Patch Check (One Of) $KBCheck" | Out-File -FilePath $PostOutFile -Append -Force
if (Get-command -name Get-ADComputer){

    [array]$DomainZ = @()
    $Filter = '(OperatingSystemVersion -like "10.0*") -and (OperatingSystem -notlike "*Server*")'
    $Properties = 'operatingsystemversion','operatingsystem'#,'distinguishedname'

    try {
        #Vast majority here
        $DomainZ += Get-ADComputer -SearchBase $Domain -Filter $Filter -Properties $Properties -ErrorAction Stop
    } catch {<#"Whatever"#>}
}
else {
    "Install the Rsat, foo!" | Out-File -FilePath $PostOutFile -Append -Force
    Return # Install the RSAT, Foo
}

#Loops through items passed to the 'process' parameter
#$PCList | ForEach-Object {
Foreach ($Comp in $PCList){ #"-$comp"}

    Write-Verbose -Message "$($Comp): Working on Machine"
    if ($LogFile){Write-WSMLogMessage -Message "$Section Working on Machine: $_" -LogFile $LogFile}

    #ScriptBlock is the script that will be triggered by the job associated with the process.
    #This is referenced in the "ScriptBlock" parameter of the Start-Job cmdlet

    if ($AdInspection = $Domainz | Where-Object {$_.Name -Match $Comp}){

        $ScriptBlock = {

            ########### For Testing for more advanced console output. ############
            #$VerbosePreference='continue'

            #Import variables
            # Assign $_ to a var with the "using" variable so we can pull external variables into this scope
            $Comp = $using:Comp
            $JobName = $Using:JobName
            $ResultFile = $using:PostOutFile
            $AdInspection = $using:AdInspection
            $TargetPatches = $Using:TargetPatches
            $KBCheck = $Using:KBCheck
            $Copy = $using:Media
            $PublicSource = $Using:PublicSource
            $PreReqs = $Using:Prereqs
            $TargetOSObj = $Using:TargetOSObj

            #Internal Variables
            $OSName = "Unknown"
            $OkayToProceed = $null
            $KBInspection = $null
            $MissingPrereqs = $null

            $OldMedia = @(
                'McAfee_VirusScanEnterprise_8.8P9_PKG_WKS',
                'McAfee_VirusScanEnterprise_8.8P8_PKG_WKS',
                'McAfee_ENS_10.5.3_PKG_All',
                'McAfee_ENS_10.5.4_PKG_All',
                'McAfee_HIPS_8.0P8_PKG_All',
                'McAfee_HIPS_8.0P7_PKG_All',
                'Microsoft_KB2738812_1.0_PKG_All',
                'Microsoft_OfficeProPlus_2010SP1_PKG_All',
                'Microsoft_OfficeProPlus_2010SP2_PKG_All',
                'Adobe_AcrobatProfessional_10_PKG_All',
                'Microsoft_SCCMClient_2007SP2_All',
                'Microsoft_CMClient_1802_PKG_All',
                'Microsoft_CMClient_1809_PKG_All'
            )

            $AD_Record = 'Valid'
            #If there is a record in AD attempt to contact the device. #trying test path as well because test connection lies. 

            <#
            Give extra attention here. Move away from the test path and use the protocol check to hit WinRM.
            #>
            if (($DeviceIP = Test-Connection -ComputerName $Comp -Count 3 -ErrorAction SilentlyContinue) -and (Test-Path -Path "\\$Comp\c$" -ErrorAction SilentlyContinue)){
                "Working on device: $Comp" | Out-File -FilePath $ResultFile -Append -Force

                #region - Add Functions

                Function Get-WSMWMIQuery {
                    <#
                    .DESCRIPTION
                        Simplify the creation of WMI Queries
                    .Example

                        (Get-WSMWMIQuery -Class Win32_OperatingSystem).Result
                        SystemDirectory     Organization                  BuildNumber RegisteredUser    SerialNumber            Version    PSComputerName
                        ---------------     ------------                  ----------- --------------    ------------            -------    --------------
                        C:\WINDOWS\system32 CONTOSO Corporation 17763       CONTOSO 00329-00000-00003-AA471 10.0.17763 LOCALHOST

                        PS U:\> (Get-WSMWMIQuery -Query "SELECT * FROM Win32_QuickFixEngineering WHERE HotFiXID = 'KB4511553' OR HotFiXID = 'KB4512937'").Result

                        Source        Description      HotFixID      InstalledBy          InstalledOn               PSComputerName
                        ------        -----------      --------      -----------          -----------               --------------
                                      Security Update  KB4512937                                                    LOCALHOST                                                                         
                                      Security Update  KB4511553     NT AUTHORITY\SYSTEM  8/22/2019 12:00:00 AM     LOCALHOST

                        DiskSpace Query: "SELECT * FROM win32_Logicaldisk WHERE VolumeName = 'OSDisk' OR DeviceID = 'C:'"
                        HotFix Query: "SELECT * FROM Win32_QuickFixEngineering WHERE HotFiXID = 'KB4511553' OR HotFiXID = 'KB4512937'"
                        File Query : 
                    #> 
                    Param (
                        [Parameter(ValueFromPipelineByPropertyName=$true)]
                        [Bool]$WinRM = $true,

                        [Parameter(ValueFromPipelineByPropertyName=$true)]
                        [string]$ComputerName = 'LOCALHOST',

                        [Parameter(ParameterSetName='Query',
                            ValueFromPipelineByPropertyName=$true)]
                        [ValidateNotNullOrEmpty()]
                        [string]$Query,

                        [Parameter(ParameterSetName='Class',
                            ValueFromPipelineByPropertyName=$true)]
                        [ValidateNotNullOrEmpty()]
                        [string]$Class
                    )
                    begin {
                        $WMIQuery = $null
                        $Failure = $null
                    }
                    Process {

                        try {
                            foreach ($try in 1..10){
                                if ($Query -and ($WinRM -eq $true)){
                                    if ($WMIQuery = Get-CimInstance -ComputerName $ComputerName -Query $Query){break}
                                }
                                elseif ($Query -and ($WinRM -eq $false)){
                                    if ($WMIQuery = Get-WmiObject -ComputerName $ComputerName -Query $Query){break}
                                }
                                elseif ($Class -and ($WinRM -eq $true)){
                                    if ($WMIQuery = Get-CimInstance -ComputerName $ComputerName -ClassName $Class){break}
                                }
                                elseif ($Class -and ($WinRM -eq $false)){
                                    if ($WMIQuery = Get-WmiObject -ComputerName $ComputerName -Class $Class){break}
                                }
                                Start-Sleep -Seconds 2 # give the system a change to retry
                            } # foreach ($try in 1..10){
                        }
                        catch [System.UnauthorizedAccessException]{
                            $Failure = "$ComputerName : Access is denied"
                        }
                        catch [System.Management.Automation.RuntimeException]{
                            $Failure = "$ComputerName : Exception Message: $($_.Exception.Message)"
                        }
                        catch [Microsoft.Management.Infrastructure.CimException]{
                            $Failure = "$ComputerName : WinRM likely not enabled: $($_.Exception.Message)"
                        }
                        catch {
                            $Failure = "$ComputerName : WMI May be corrupt, expect other issues. Type to catch [$($_.exception.GetType().fullname)] Exception Message: $($_.Exception.Message)"
                        }

                        #Return the query result
                        [PSCustomObject]@{
                            Result = $WMIQuery
                            Failure = $Failure
                        }
                    }
                } # Function Get-WSMWMIQuery {

                Function Invoke-WSMWMIMethod {
                    <#
                    .Description
                        Simplify some WMI method calls based on how they're used here in this script.
                    #>
                    Param (
                        [Parameter(ValueFromPipelineByPropertyName=$true)]
                        [Bool]$WinRM = $true,

                        [Parameter(ValueFromPipelineByPropertyName=$true)]
                        [string]$Comp = 'LOCALHOST',

                        [Parameter(ValueFromPipelineByPropertyName=$true)]
                        [ValidateNotNullOrEmpty()]
                        [string[]]$Arguments,

                        [Parameter(ValueFromPipelineByPropertyName=$true)]
                        [ValidateNotNullOrEmpty()]
                        [string]$MethodName,

                        [Parameter(ValueFromPipelineByPropertyName=$true)]
                        [ValidateNotNullOrEmpty()]
                        [string]$Class
                    )
                    begin {
                        $WMIMethod = $null
                        $Failure = $null
                    }
                    Process {

                        try {
                            foreach ($try in 1..10){
                                if ($WinRM -eq $true){

                                    $Args = @{
                                        CommandLine = $Arguments
                                        CurrentDirectory = $null
                                        ProcessStartupInformation = $null
                                    }

                                    if ($WMIMethod = Invoke-CimMethod -ComputerName $Comp -ClassName $Class -MethodName $MethodName -Arguments $Args -ErrorAction Stop){break}
                                }
                                elseif ($WinRM -eq $false){
                                    if ($WMIMethod = Invoke-WmiMethod -ComputerName $Comp -class $Class -Name $MethodName -ArgumentList $Arguments){break}
                                }
                                Start-Sleep -Seconds 2 # give the system a change to retry
                            } # foreach ($try in 1..10){
                        } # try {
                        catch [System.UnauthorizedAccessException]{
                            $Failure = "$($Comp): Access is denied"
                        }
                        catch [System.Management.Automation.RuntimeException]{
                            $Failure = "$($Comp): Exception Message: $($_.Exception.Message)"
                        }
                        catch {
                            $Failure = "$($Comp): WMI May be corrupt, expect other issues. Type to catch [$($_.exception.GetType().fullname)] Exception Message: $($_.Exception.Message)"
                        }

                        #Return the query result
                        [PSCustomObject]@{
                            Result = $WMIMethod
                            Failure = $Failure
                        }
                    } # Process {
                } # Function Invoke-WSMWMIMethod {

                #endregion - Add Functions

                #region - Gather system info

                Write-Verbose -Message "$($Comp): Attempting to establish WMI\CIM connection" 

                #Try WMI via RPC to see if that's open
                $WMI_RPCQuery = Get-WSMWMIQuery -ComputerName $Comp -WinRM $false -Class Win32_OperatingSystem
                if ($WMI_OSData = $WMI_RPCQuery.Result){
                    $WMIConnects = $true
                    $Access = $true # <-------- Look at this closer, might be superflous
                    $WMIInfo = 'Healthy'
                }
                if ($WMIInfo = $WMI_RPCQuery.Failure){
                    $WMIInfo | Out-File -FilePath $ResultFile -Append -Force
                    $WMIConnects = $false
                }

                # Try WinRM - 'Powershell Remoting'
                $WMI_CIMQuery = Get-WSMWMIQuery -ComputerName $Comp -WinRM $true -Class Win32_OperatingSystem
                if ($CIM_OSData = $WMI_CIMQuery.Result){
                    $CIMConnects = $true
                    $Access = $true # <-------- Look at this closer, might be superflous
                    $CIMInfo = 'Healthy'
                    $WinRM = $true # From here on out we use this variable for the WinRM parameter
                }
                if ($CIMInfo = $WMI_CIMQuery.Failure){
                    $CIMInfo | Out-File -FilePath $ResultFile -Append -Force
                    $CIMConnects = $false
                    $WinRM = $false # From here on out we use this variable for the WinRM parameter
                }

                <#
                    Get the OS Name - Get this regardless
                #>
                try {
                    if ((& reg query "\\$Comp\HKLM\SOFTWARE\Microsoft\MPSD\OSD" /v OSDComputerName 2>&1)){
                        $RegName = (& reg query "\\$Comp\HKLM\SOFTWARE\Microsoft\MPSD\OSD" /v OSDComputerName 2>&1)[2].replace('OSDComputerName','').replace('REG_SZ','').trim()
                    }
                }
                catch {
                    #'Probably didn't return anything and the replace method is barking..
                    "Error: Reading OS Key: $($_.Exception.Message)" | Out-File -FilePath $ResultFile -Append -Force
                }

                try {

                    #region - Gather basic info

                    Write-Verbose -message "$($Comp): Checking WMI for OS type"
                    # Rely on the same try block
                    if ($CIMConnects){
                        $WMIName = $CIM_OSData.PSComputerName
                        $OSName = $CIM_OSData.Caption # this is more betterer than .Name, which is full of other garbage that would otherwise need to be parsed...and I'm lazy
                        $OSVer = $CIM_OSData.Version
                        $OSProdType = $CIM_OSData.ProductType # Type 1 = Workstation;Type 2 = Domain Controller;Type 3 = Server
                        $OSArch = $CIM_OSData.OSArchitecture
                        $OSBuild = $CIM_OSData.BuildNumber
                    }
                    elseif ($WMIConnects){
                        $WMIName = $WMI_OSData.PSComputerName
                        $OSName = $WMI_OSData.Caption 
                        $OSVer = $WMI_OSData.Version
                        $OSProdType = $WMI_OSData.ProductType # Type 1 = Workstation;Type 2 = Domain Controller;Type 3 = Server
                        $OSArch = $WMI_OSData.OSArchitecture
                        $OSBuild = $WMI_OSData.BuildNumber
                    } # elseif ($WMIConnects){

                    $MainPatchObjs = $TargetPatches.Where({$_.Build -eq $OSBuild})

                    #Check Disk Space
                    $PreFreeSpace = ((Get-WSMWMIQuery -ComputerName $Comp -WinRM $WinRM -Query "SELECT * FROM win32_Logicaldisk WHERE VolumeName = 'OSDisk' OR DeviceID = 'C:'").Result).FreeSpace/1GB

                    #Get the full list of the installed KBs before any patching is done.
                    $FullKBList = (Get-WSMWMIQuery -ComputerName $Comp -WinRM $WinRM -Class 'Win32_QuickFixEngineering').Result
                    #Sort through the list to see if our main KBs are present.
                    $KBInspection = ($FullKBList.HotFixID).where({$_ -match $(if (($MainPatchObjs.kb).count -gt 1){$MainPatchObjs.kb -join '|'}else{$MainPatchObjs.kb})})
                    if ($KBInspection){"$Comp : Located the following KBs: $KBInspection" | Out-File -FilePath $ResultFile -Append -Force}
                    [array]$MissingKBs = @()
                    $MissingKBs += ($MainPatchObjs.KB).where({$_ -notin $FullKBList.Hotfixid})

                    if ($MissingKBs){

                        if ($CimConnects){
                            $CheckForRebootFlag = Invoke-Command -ComputerName $Comp -ScriptBlock {
                                $CompSvc = Test-Path -path "HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\Component Based Servicing\RebootPending" -ea SilentlyContinue
                                $WinSxSXml = Test-Path -path "$env:WINDIR\winsxs\pending.xml" -ea SilentlyContinue
                                $WinUpdate = Test-Path -path 'HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\WindowsUpdate\Auto Update\RebootRequired'
                                if ($CompSvc -or $WinSxSXml -or $WinUpdate){'1'}else{'0'}
                            }
                        } # if ($CimConnects){
                        else { # either RPC or Reg only would work here
                            $WinSxSXmlPath = "C:\\winsxs\\pending.xml"
                            $WinSxSXml = (Get-WSMWMIQuery -ComputerName $Comp -WinRM $WinRM -Query "SELECT * FROM Win32_Directory WHERE Name = `'$WinSxSXmlPath`'").Result
                            $CompSvc = (& reg query "\\$Comp\HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Component Based Servicing\RebootPending" /v OSDComputerName 2>&1).Where({$_ -notmatch 'ERROR:'})
                            $WinUpdate = (& reg query "\\$Comp\HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\WindowsUpdate\Auto Update\RebootRequired" /v OSDComputerName 2>&1).Where({$_ -notmatch 'ERROR:'})
                            if ($CompSvc -or $WinSxSXml -or $WinUpdate){$CheckForRebootFlag = '1'}else{$CheckForRebootFlag = '0'}
                        }

                        #Main targeted KB must be installed after a reboot.
                        if ($CheckForRebootFlag -eq '1'){$Reboot = $true}
                        else {$Reboot = $false}

                        $Vulnerability = 'Unknown'
                        #[array]$PatchedFileCheck = @()
                        [array]$AllRequiredPatches = @()
                        
                        foreach ($File2Check in $MainPatchObjs){
                            $AllRequiredPatches += $File2Check
                        }

                        #region - Check if the prereqs are present
                            [array]$Satisfied_PreReqs = @()

                            #Filter out the KBs that would be irrelevant to the OS build
                            $PreReqs = $PreReqs.Where({$_.Build -eq $OSBuild})
                            $PreReqKBCheck = ($FullKBList.HotFixID).where({$_ -match $(if (($PreReqs.kb).count -gt 1){$PreReqs.kb -join '|'}else{$PreReqs.kb})})

                            if (!$PreReqKBCheck){

                                foreach ($PreReqObj in $PreReqs){

                                    #$SideBySideFile = "C:\\Windows\\WinSxS\\$($PreReqObj.WinSxS)"
                                    if (!(Get-HotFix -ComputerName $Comp -ID $PreReqObj.kb -ErrorAction SilentlyContinue).HotFixID){
                                        $AllRequiredPatches += $PreReqObj
                                    }
                                    else {
                                        "$Comp : Prereq: $($PreReqObj.KB) located but device may require a reboot before proceeding" | Out-File -FilePath $ResultFile -Append -Force
                                        $Satisfied_PreReqs += $PreReqObj.KB
                                    }

                                } # foreach ($PreReqKB in $PreReqs){
                            } # if (!$PreReqKBCheck){

                        #endregion - Check if the prereqs are present
                    }
                    else {
                        "$Comp : All tageted patches appear to be installed: $KBInspection" | Out-File -FilePath $ResultFile -Append -Force
                        $Vulnerability = 'Patched'
                    }

                    #endregion - Gather basic info

                    if ($CIMConnects){
                        #region - SolidCore Check
                        $SCBlock = {
                            $SolidCoreGuid = '{432DB9E4-6388-432F-9ADB-61E8782F4593}'
                            $HiveArr = @('HKLM:\SOFTWARE','HKLM:\SOFTWARE\Wow6432Node')

                            foreach ($Hive in $HiveArr){
                                $UninstDB = "$Hive\Microsoft\Windows\CurrentVersion\Uninstall"
                                $SolidCore = Get-ItemProperty -Path "$UninstDB\$SolidcoreGUID" -ErrorAction SilentlyContinue
                                if ($Solidcore){break}
                            }
                        
                            $Solidcore.DisplayVersion
                        } # $SCBlock = {

                        try {
                            $SCCheck = Invoke-Command -ComputerName $Comp -ScriptBlock $SCBlock -ErrorAction Stop
                            if  ($SCCheck){[string]$SolidCorePresent = 'true'}else{[string]$SolidCorePresent = 'false'}# I don't want the other garbage Invoke-Command puts out.
                        }
                        catch {"$Comp : Error querying for Solidcore via CIM connection" | Out-File -FilePath $ResultFile -Append -Force}

                        "$Comp SolidcCore installed: $SolidCorePresent" | Out-File -FilePath $ResultFile -Append -Force
                        #endregion - Solidcore check

                        #Check if this is a VDI
                        $RegInspectionBlock = {
                            #Really, you didn't connect to thet remote device to check this?
                            try {
                                $StatusKey = (Get-ItemProperty -Path "HKLM:\SOFTWARE\SPECIALKEY\DCM\McAfee_VDI" -ErrorAction SilentlyContinue).status
                            }
                            catch {
                                #Whatever
                            }
                            $StatusKey
                        }

                        try {
                            $StatusKey = Invoke-Command -ComputerName $Comp -ScriptBlock $RegInspectionBlock -ErrorAction SilentlyContinue
                        }
                        catch {
                            "$Comp : Error querying VDISkip via CIM connection" | Out-File -FilePath $ResultFile -Append -Force
                        }
                        if ($StatusKey -eq 'Skip'){$VDISkip = 'Skip'}else{$VDISkip = $null}

                    }
                    elseif ($WMIConnects){

                        #Is this a MFG box in hiding? Should use WMI here, but it's a lot more work than I want to do right now. :(
                        if ((& reg query "\\$Comp\HKLM\SOFTWARE\SPECIALKEY\baseline" /v PushRestricted 2>&1)){
                            $PushRestricted = (& reg query "\\$Comp\HKLM\SOFTWARE\SPECIALKEY\baseline" /v PushRestricted 2>&1)[2].replace('PushRestricted','').replace('REG_SZ','').trim()
                        }
                        "$Comp is has Push restricted set to: $PushRestricted" | Out-File -FilePath $ResultFile -Append -Force

                        #region - SolidCore Check
                            $SolidCoreGuid = '{432DB9E4-6388-432F-9ADB-61E8782F4593}'
                            $HiveArr = @('HKLM\SOFTWARE','HKLM\SOFTWARE\Wow6432Node')

                            foreach ($Hive in $HiveArr){
                                $UninstDB = "$Hive\Microsoft\Windows\CurrentVersion\Uninstall"
                                if ($SolidCore = (& reg query "\\$Comp\$UninstDB\$SolidcoreGUID" /v DisplayName 2>&1)){break}
                            }
                            if ($Solidcore){
                                $SolidCorePresent = $true
                            }
                            else {
                                $SolidCorePresent = $false
                            }

                            "$Comp SolidcCore installed: $SolidCorePresent" | Out-File -FilePath $ResultFile -Append -Force
                        #endregion - SolidCore Check

                        #Check if this is a VDI
                        if ((& reg query "\\$Comp\HKLM\SOFTWARE\SPECIALKEY\DCM\McAfee_VDI" /v status 2>&1)){
                            $VDISkip = (& reg query "\\$Comp\HKLM\SOFTWARE\SPECIALKEY\DCM\McAfee_VDI" /v status 2>&1)[2].replace('status','').replace('REG_SZ','').trim()
                        }

                    }
                    #Try the registry
                    elseif (($OSName = (& reg query "\\$Comp\HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion" /v ProductName 2>&1)) -match 'REG_SZ'){

                        "$($Comp): Everything else has failed, checking Registry." | Out-File -FilePath $ResultFile -Append -Force

                        try {
                            #Clean the output
                            $OSName = $OSName[2].replace('ProductName','').replace('REG_SZ','').trim()

                            #Get the version
                            $OSVer = (& reg query "\\$Comp\HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion" /v CurrentVersion 2>&1) # Major.Minor
                            $OSVer = $OSVer[2].replace('CurrentVersion','').replace('REG_SZ','').trim()

                            # Get the OS type
                            if ((& reg query "\\$Comp\HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion" /v InstallationType 2>&1) -match 'client'){
                                $OSProdType = '1'
                            }
                            else { $OSProdType = '3' }

                        }
                        catch {
                            "$($Comp): Error - In OS Checking region using Reg.exe: $($_.Exception.Message)" | Out-File -FilePath $ResultFile -Append -Force
                        }

                        #Is this a MFG box in hiding?
                        if ((& reg query "\\$Comp\HKLM\SOFTWARE\SPECIALKEY\baseline" /v PushRestricted 2>&1)){
                            $PushRestricted = (& reg query "\\$Comp\HKLM\SOFTWARE\SPECIALKEY\baseline" /v PushRestricted 2>&1)[2].replace('PushRestricted','').replace('REG_SZ','').trim()
                        }

                        $HiveArr = @('HKLM\SOFTWARE','HKLM\SOFTWARE\Wow6432Node')

                        if ((& reg query "\\$Comp\HKLM\SOFTWARE\Wow6432Node\Microsoft\Windows NT\CurrentVersion" /v InstallationType 2>&1)){$OSArch = '64-bit'}
                        else {$OSArch = '32-bit'}

                        #region - SolidCore Check
                        $SolidCoreGuid = '{432DB9E4-6388-432F-9ADB-61E8782F4593}'

                        foreach ($Hive in $HiveArr){
                            $UninstDB = "$Hive\Microsoft\Windows\CurrentVersion\Uninstall"
                            if ($SolidCore = (& reg query "\\$Comp\$UninstDB\$SolidcoreGUID" /v DisplayName 2>&1)){break}
                        }
                        if ($Solidcore){
                            $SolidCorePresent = $true
                        }
                        else {
                            $SolidCorePresent = $false
                        }
                        #endregion - SolidCore Check

                        try {
                            $RegQuery = & reg query "\\$Comp\HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Component Based Servicing\Packages"
                            $KBInspection = (($RegQuery | Where-Object {$_ -match $KBCheck} | 
                                ForEach-Object {(Split-Path $_ -Leaf -ErrorAction SilentlyContinue)} ).foreach({($_.split('_'))[-1].split('~')[0]})) | 
                                    Select-Object -Unique
                            if ($KBInspection.count -eq ($MainPatchObjs.kb).count){
                                "$Comp The KB Count when checked by the registry counts the device as being patched." | Out-File -FilePath $ResultFile -Append -Force 
                                $Vulnerability = 'Patched'
                            }
                        }
                        catch {
                            "$($Comp): Error - Had issue querying if a registry key existed. $($_.Exception.Message)" | Out-File -FilePath $ResultFile -Append -Force
                        }

                        #Check if this is a VDI
                        if ((& reg query "\\$Comp\HKLM\SOFTWARE\SPECIALKEY\DCM\McAfee_VDI" /v status 2>&1)){
                            $VDISkip = (& reg query "\\$Comp\HKLM\SOFTWARE\SPECIALKEY\DCM\McAfee_VDI" /v status 2>&1)[2].replace('status','').replace('REG_SZ','').trim()
                        }

                        $Access = $true
                    }
                    else {
                        #I'm out of ways to try here, there's probably a few more that don't include leveraging questionable exploits.
                        "$Comp : is not allowing access and cannot be managed by this script (or at least this user)." | Out-File -FilePath $ResultFile -Append -Force
                        $Access = $false
                    }
                }
                catch [System.UnauthorizedAccessException]{
                    "$($Comp): Access is denied" | Out-File -FilePath $ResultFile -Append -Force
                    $Access = $false
                }
                catch [System.Management.Automation.RuntimeException]{
                    "$($Comp): Exception Message: $($_.Exception.Message)" | Out-File -FilePath $ResultFile -Append -Force
                }
                catch {
                    "$($Comp): WMI May be corrupt, expect other issues. Type to catch [$($_.exception.GetType().fullname)] Exception Message: $($_.Exception.Message)" | Out-File -FilePath $ResultFile -Append -Force
                    $WMIConnects = $false
                }
                #endregion - Gather system info

                <#
                Commenting this out because I'm going to try hitting Solidcore devices without doing anything other than installing patches.
                This is mainly because these latest RDP vulnerabilities will probably bypass Solidcore
                if ($SolidCorePresent -eq $true){$OkayToProceed = $false}
                #>

                #region - Check if it's the correct device and OS

                #Make sure Name Matches - Keeping this separate as it's a bit of a bear
                #If either WinRM or WMI connected check if the result matches the device we're attempting to target
                #check against the device name in the registry and the
                if ( ($CIMConnects -or $WMIConnects) -and ($VDISkip -eq 'skip') ){
                    #Need this to get past the goofy naming conventions we see on VDIs
                    "$Comp : Name Check passed - Device is VDI" | Out-File -FilePath $ResultFile -Append -Force
                    $NameCheck = 'Pass'
                }
                elseif ( ( ($CIMConnects -or $WMIConnects) -and ( ($WMIName -ne $Comp) -or ($RegName -and ($WMIName -ne $RegName) ) ) ) -or ($RegName -and ($RegName -ne $Comp) ) ){
                    $NameCheck = 'Failed'
                    "$Comp : Name Check faled" | Out-File -FilePath $ResultFile -Append -Force
                }
                else {
                    $NameCheck = 'Pass'
                    "$Comp : Name check passed defaults" | Out-File -FilePath $ResultFile -Append -Force
                }

                #In this case it must be Windows 7 (Not a server i.e. 2008 R2 "v6.1 type 3")
                #check gathered data to ensure proper OS is being targeted - $TargetOSObj.Version
                if ( ("$($OSVer.Major).$($OSVer.Minor)" -ne $TargetOSObj.Version) -and ($OSProdType -ne $TargetOSObj.Type) ){
                    "$($Comp): Device is not the target OS ($OSName), the script will not run on this box." | Out-File -FilePath $ResultFile -Append -Force
                    $OkayToProceed = $false
                }
                elseif ($OSArch -match "32|86"){
                    #This is not built to handle 32 bit Windows 10
                    $OkayToProceed = $false
                    "$($Comp): Error - OS Arch not supported $OsArch." | Out-File -FilePath $ResultFile -Append -Force
                }
                elseif ($NameCheck -match 'Failed'){
                    $OkayToProceed = $false
                    "$($Comp): Error - Device failed Name check." | Out-File -FilePath $ResultFile -Append -Force
                }
                #I'm thinking this elseif doesn't really translate well
                elseif ( ($OSLines -match "RPC") -or ($OSName -match "ERROR: Invalid syntax") ){
                    $OkayToProceed = $false
                    "$($Comp): Error - Device may be in a bad state. Device may need attention by Desktop services" | Out-File -FilePath $ResultFile -Append -Force
                }
                elseif ($Reboot -eq $true){
                    #$OkayToProceed = $false
                    $Reboot -eq $false
                    $OkayToProceed = $true
                    "$($Comp): Warning - Device may be may require a reboot before patch can be installed, but we'll try anyway..." | Out-File -FilePath $ResultFile -Append -Force
                }
                else {
                    #Write-verbose -Message 
                    "$($Comp): Proper OS Detected ($OSName). Proceeding..." | Out-File -FilePath $ResultFile -Append -Force
                    $OkayToProceed = $true
                }

                #endregion - Check if it's the correct device and OS

                #If the update hasn't been found already
                if ( ($OkayToProceed -eq $true) -and ($Access -eq $true) ){

                    #region - Copy files to local device
                        "$Comp : Device missing These KB's `'$MissingKBs`'. Vunerability state = $Vulnerability" | Out-File -FilePath $ResultFile -Append -Force
                        if ($MissingKBs -and ($Vulnerability -ne 'Patched')){

                            $AttemptPatch = $true

                            #We should already have the Windows version at this point. We only need the os Arch to make this decision
                            if ($OSArch -match "64"){
                                $Wus = "$env:systemroot\SysWOW64\wusa.exe"
                            }

                            #Of all the dumbass things... Why check if I can get to the public source from the hosting device?
                            $SourceCheck = ($MainPatchObjs).foreach({
                                if (Test-Path -Path "$PublicSource\$($_.Build)\$($_.msufile)" -ErrorAction SilentlyContinue){
                                    "$Comp : The required patch was located in the public source." | Out-File -FilePath $ResultFile -Append -Force
                                    $true
                                }
                                else {
                                    "$Comp : Warning - The required patch was NOT located in the public source!" | Out-File -FilePath $ResultFile -Append -Force
                                    $false
                                }
                            })
                            if ($SourceCheck -contains $false){$KBCopy = $Copy}
                            else {$KBCopy = $PublicSource}
                            "$Comp : will attempt to copy main patch from source $KBCopy" | Out-File -FilePath $ResultFile -Append -Force

                            <#
                                #################################
                                #
                                # - Copy the files to the target device
                                # - Something in the copy section is still pumping out to the log file.
                                #       I have mixed feeling about that.
                                #
                                #################################
                            #>

                            #region - Check file integrity
                                if ($AllRequiredPatches){

                                    foreach ($PObj in $AllRequiredPatches){

                                        $PatchFile = $PObj.MSUFile
                                        $KBname = $PObj.KB
                                        $PatchFileRemotePath = "C:\\Windows\\Temp\\$KBname\\$PatchFile"
                                        $MediaExists = (Get-WSMWMIQuery -ComputerName $Comp -WinRM $WinRM -Query "SELECT * FROM CIM_DataFile WHERE Name = `'$PatchFileRemotePath`'").Result

                                        if ($MediaExists){

                                            if ($CIMConnects){

                                                #Since the hash can be inspected
                                                <#There's an issue with this that is not representing outside of this script#>
                                                [string]$KBHash = Invoke-Command -Computername $Comp -ScriptBlock {
                                                    param($KBname,$PatchFile)
                                                    (Get-FileHash -Path "C:\Windows\Temp\$KBname\$PatchFile").Hash
                                                } -ArgumentList $KBname,$PatchFile -ErrorAction SilentlyContinue

                                                $SourceHash = (Get-FileHash -Path "$KBCopy\$($PObj.Build)\$PatchFile" -ErrorAction SilentlyContinue).Hash
                                                $IntegrityCheck = ($KBHash -eq $SourceHash)
                                                "$Comp : Source file hash taken from: $("$KBCopy\$($PObj.Build)\$PatchFile")" | Out-File -FilePath $ResultFile -Append -Force
                                                "$Comp : Local Hash = $KBHash Source Hash = $SourceHash" | Out-File -FilePath $ResultFile -Append -Force
                                            }
                                            elseif ($WMIConnects){
                                                #I can't seem to get the WMI hash check working so we'll look at the file size
                                                $IntegrityCheck = ((Get-Item -Path "$KBCopy\$($PObj.Build)\$PatchFile" -ErrorAction SilentlyContinue).Length -eq $MediaExists.FileSize)
                                            }

                                            if (!$IntegrityCheck){
                                                # Remove the previously transferred files
                                                try {
                                                    $PRRemoteDir = "C:\\Windows\\Temp\\$KBname"
                                                    if ($CIMConnects){
                                                        $DeletePreviousKB = (Get-CimInstance -Computername $Comp -Query "SELECT * FROM Win32_Directory WHERE Name = `'$PRRemoteDir`'" | 
                                                            Invoke-CimMethod -MethodName Delete -ErrorAction Stop)
                                                    }
                                                    elseif ($WMIConnects){
                                                        $DeletePreviousKB = (Get-WmiObject -Computername $Comp -Query "SELECT * FROM Win32_Directory WHERE Name = `'$PRRemoteDir`'" -ErrorAction Stop).Delete()
                                                    }

                                                    $MediaExists = $null
                                                    "$($Comp): Successfully deleted media $($PatchFile) that had a hash mismatch" | Out-File -FilePath $ResultFile -Append -Force
                                                }
                                                catch {
                                                    "$($Comp): Error in attempting to delete media $($PatchFile) that failed Hash file check: $($_.Exception.Message)" | Out-File -FilePath $ResultFile -Append -Force
                                                }
                                            } # if ($KBHash -ne (Get-FileHash -Path "$KBCopy\$($PObj.Build)\$PatchFile" -ErrorAction SilentlyContinue).Hash){
                                            else {"$($Comp): No issue with media $($PatchFile) detected. Resuming install..." | Out-File -FilePath $ResultFile -Append -Force}
                                        } # if ($MediaExists){
                                        else {
                                            "$($Comp): No existing media found to inspect `'$PatchFileRemotePath`'. Resuming install..." | Out-File -FilePath $ResultFile -Append -Force
                                        }
                                    } # foreach ($PObj in $AllRequiredPatches){
                                } # if ($AllRequiredPatches){

                            #endregion - Check file integrity

                            #region - Check\Make free space
                                if ($CIMConnects){

                                    if ($PreFreeSpace -lt 2){

                                        $CleanBlock = {
                                            Param($OldMedia)
                                            $SpecialMedia = "$env:ALLUSERSPROFILE\SpecialFolder\SpecialMedia"

                                            foreach ($Item in $OldMedia){
                                                if (Get-item -Path "$SpecialMedia\$Item" -ErrorAction SilentlyContinue){
                                                    try {
                                                        $null = Remove-Item -Path "$SpecialMedia\$Item" -Recurse -Force -ErrorAction Stop
                                                    }
                                                    catch {
                                                        Write-Verbose -Message $_.Exception.Message
                                                    }
                                                }
                                            } # foreach ($Item in $OldMedia){

                                            #This Code block was boosted from MS support formums - KVB
                                            ## Initialize the CCM resource manager com object
                                            [__comobject]$CCMComObject = New-Object -ComObject 'UIResource.UIResourceMgr'
                                            ## Get the CacheElementIDs to delete
                                            $CacheInfo = $CCMComObject.GetCacheInfo().GetCacheElements()
                                            ## Remove cache items
                                            ForEach ($CacheItem in $CacheInfo){
                                                $null = $CCMComObject.GetCacheInfo().DeleteCacheElement([string]$($CacheItem.CacheElementID))
                                            }
                                            Start-sleep -Seconds 30
                                        } # $CleanBlock = {

                                        #Remove some of the lingering items from Special media and then CcmCache
                                        $Null = Invoke-Command -ComputerName $Comp -ScriptBlock $CleanBlock -ArgumentList $OldMedia
                                        $PreFreeSpace = ((Get-CimInstance -ComputerName $Comp -ClassName win32_Logicaldisk -ErrorAction SilentlyContinue | Where-Object {($_.VolumeName -eq 'OSDisk') -or ($_.DeviceID -eq "C:")}).FreeSpace/1GB)
                                        $CleanupAttempt = $true
                                    }

                                } # if ($CIMConnects){
                                elseif ($WMIConnects){
                                    if ($PreFreeSpace -lt 2){
                                        $SpecialMedia = "C:\\ProgramData\\SPECIAL\\SpecialMedia"

                                        foreach ($OldItem in $OldMedia){
                                            $OrphanedObj = "$SpecialMedia\\$OldItem"
                                            if ($FileObject = Get-WmiObject -ComputerName $Comp -Query "Select * From Win32_Directory Where Name =`'$OrphanedObj`'" -ErrorAction SilentlyContinue){
                                                #Attempt to remove the file
                                                try {
                                                    $FileObject | Remove-WmiObject -ErrorAction Stop
                                                }
                                                catch {
                                                    Write-Verbose -Message $_.Exception.Message
                                                }
                                            } # FileObject
                                        } # foreach ($OldItem in $OldMedia){
                                    } # if ($PreFreeSpace -lt 1){
                                } # elseif ($WMIConnects){
                            #endregion - Check\Make free space

                            #region - copy the files
                            if (!$MediaExists){

                                <#
                                    This solution sucks, but if I'm going to get around devices with no RPC access, this is it for the time being. 
                                    If we can get a gMSA account going we can do point to point copies via PS, until then this seems to be the best solution.
                                #>
                                $RemotePsE = $null
                                if ($KBCopy -eq $PublicSource){
                                    try {
                                        if ($CIMConnects){
                                           $CopySession = New-PSSession -ComputerName $Comp -SessionOption (New-PSSessionOption -NoMachineProfile) -ErrorAction Stop
                                            $Null = Copy-Item -Path "$Copy\PsExec.exe" -Destination "$env:windir\Temp\" -Force -ToSession $CopySession -ErrorAction Stop 
                                            "$Comp : No issues recorded while copying psexec to remote device." | Out-File -FilePath $ResultFile -Append -Force
                                        }
                                        else {
                                            $Null = (& robocopy $Copy "\\$Comp\C$\Windows\Temp" "PsExec.exe" /S /MT:50 /r:30 /w:05 2>&1)
                                        }
                                    }
                                    catch {
                                        "$Comp : Failed to copy psexec to device - $($_.Exception.Message)" | Out-File -FilePath $ResultFile -Append -Force
                                    }
                                    finally {
                                        if ($CIMConnects){
                                            $null = Remove-PSSession -Session $CopySession -ErrorAction SilentlyContinue
                                        }
                                        #Just because the copy may have failed here doesn't mean it might not have been copied there on a previous attempt or by some other script.
                                        $PsERemotePath = "C:\\Windows\\Temp\\Psexec.exe"
                                        $RemotePsE = (Get-WSMWMIQuery -ComputerName $Comp -WinRM $WinRM -Query "SELECT * FROM CIM_DataFile WHERE Name = `'$PsERemotePath`'").Result
                                        "$Comp : Result of PSExec check on remote device - $RemotePsE" | Out-File -FilePath $ResultFile -Append -Force
                                    }
                                } # if ($KBCopy -eq $PublicSource){

                                if ($RemotePsE){
                                    if ($CIMConnects){
                                        $RemotePath = "$PublicSource\$OSBuild"
                                        "$Comp : Script will attempt to copy from  - `'$RemotePath`'"  | Out-File -FilePath $ResultFile -Append -Force
                                        $AllRequiredPatches | ForEach-Object {
                                            "$Comp : Script will attempt to copy this patch from above location  - `'$($_.MSUFile)`'"  | Out-File -FilePath $ResultFile -Append -Force
                                        }

                                        $RemoteCopyBlock = {
                                            Param($AllRequiredPatches,$PublicSource,$RemotePath)
                                            [array]$FileCheck = $()
                                            foreach ($PatchObj in $AllRequiredPatches){
                                                #$RemotePath = "$PublicSource\$($PatchObj.Build)"
                                                $Patch = $PatchObj.MSUFile
                                                $PowerShellCmd = "%winDir%\System32\WindowsPowerShell\v1.0\powershell.exe -NoLogo -NonInteractive -NoProfile -WindowStyle Hidden" # sysnative pukes here so stick to system32
                                                $TargetDir = "$($env:Windir)\Temp\$($PatchObj.KB)"
                                                $Robocopy = "$($env:Windir)\System32\robocopy.exe $RemotePath $TargetDir $Patch /S /MT:50 /r:30 /w:05"

                                                #Check if the remote content is visible
                                                $CheckPath = (& C:\Windows\Temp\Psexec.exe -accepteula -s cmd /c $PowerShellCmd Test-Path -path "$RemotePath\$Patch" -ErrorAction SilentlyContinue 2>&1).where({$_ -match 'True|False'})
                                                if ($CheckPath -eq $true){
                                                    try {
                                                        #Return is largley useless, or there's a lot of parsing to be done that I just assume leave be. 
                                                        $null = (Start-Process -FilePath 'C:\Windows\Temp\Psexec.exe' -ArgumentList "-accepteula -s cmd.exe /c $Robocopy" -PassThru -Wait)
                                                    }
                                                    catch {
                                                        #Something went wrong
                                                    }
                                                    finally {
                                                        if ( !(Test-Path -Path "$TargetDir\$Patch" -ErrorAction SilentlyContinue) ){$FileCheck = $False}
                                                        else {$FileCheck += "$TargetDir\$Patch"}
                                                    }
                                                } # if ($CheckPath -eq $true){}
                                            } # foreach ($PatchObj in $AllRequiredPatches){

                                            $FileCheck # This is useless for the most part but I don't want to deal with inspecting the file's presense in the remote code block

                                        } # $RemoteCopyBlock = {

                                        $FileCopyBlocKResult = (Invoke-Command -ComputerName $Comp -ScriptBlock $RemoteCopyBlock -ArgumentList $AllRequiredPatches,$PublicSource)
                                        "$Comp : File copy script block result  - $FileCopyBlocKResult"  | Out-File -FilePath $ResultFile -Append -Force
                                    } # if ($CIMConnects){
                                    else {
                                        #Try Robocopy via RPC
                                        #This will work even if WMI is broken so the else block should work.
                                        foreach ($PatchObj in $AllRequiredPatches){
                                            $Patch = $PatchObj.MSUFile
                                            $CopyFiles = (& robocopy "$Copy\$($PatchObj.Build)" "\\$Comp\C$\Windows\Temp\$($PatchObj.KB)" $Patch /S /MT:50 /r:30 /w:05 2>&1) # once again, returns are basically useless here.
                                            "$Comp : Robocopy result - $CopyFiles" | Out-File -FilePath $ResultFile -Append -Force
                                            if ($CopyFiles -match "Invalid Drive|ERROR"){
                                                "$($Comp):Error - Cannot access the drive. Listing this device as a failure: $Comp" | Out-File -FilePath $ResultFile -Append -Force
                                                #$FileCopied = $false
                                            }
                                        } # foreach ($PatchObj in $AllRequiredPatches){
                                    } # else {
                                    $CopyLocation = $PublicSource
                                } # if ($RemotePsE){

                                #If the media was missing at first we're goign to step in here incase the remote location copy wasn't working.
                                foreach ($PatchObj in $AllRequiredPatches){
                                    $Patch = $PatchObj.MSUFile
                                    $KBRemoteDir = "C:\Windows\Temp\$($PatchObj.KB)"
                                    $KBRemotePath = "$KBRemoteDir\$Patch"
                                    $KBRemotePathWMI = $KBRemotePath.replace('\','\\')

                                    $RemoteKB = $null # should get cleaned on each inspection, but just in case...
                                    $RemoteKB = (Get-WSMWMIQuery -ComputerName $Comp -WinRM $WinRM -Query "SELECT * FROM CIM_DataFile WHERE Name = `'$KBRemotePathWMI`'").Result

                                    #I don't want to check the file integrity again (lazy...)
                                    #If the file is still missing we'll attempt to copy it using WinRM and RPC from the cache on the hosting device.
                                    if (!$RemoteKB){
                                        "$Comp : Media for $($PatchObj.KB) still not found on device. Using hosting device as a facilitator." | Out-File -FilePath $ResultFile -Append -Force

                                        try {
                                            if ($CIMConnects){
                                                $CopySession = New-PSSession -ComputerName $Comp -SessionOption (New-PSSessionOption -NoMachineProfile) -ErrorAction Stop
                                                $NewItemBlock = {
                                                    param($KBRemoteDir)

                                                    if (!(Test-Path -Path $KBRemoteDir)){$null = New-Item -Path $KBRemoteDir -ItemType Directory -force}
                                                    Test-Path -Path $KBRemoteDir -ErrorAction SilentlyContinue # output to the invoke command
                                                }
                                                $CreateDir = Invoke-Command -Session $CopySession -ScriptBlock $NewItemBlock -ArgumentList $KBRemoteDir
                                                if ($CreateDir){
                                                    $null = Copy-Item -Path "$Copy\$($PatchObj.Build)\$Patch" -Destination "$KBRemoteDir\" -Force -ToSession $CopySession -ErrorAction Stop
                                                    $RemoteKB = (Get-WSMWMIQuery -ComputerName $Comp -WinRM $WinRM -Query "SELECT * FROM CIM_DataFile WHERE Name = `'$KBRemotePathWMI`'").Result
                                                }
                                            } # if ($CIMConnects){

                                            #This is to catch failed CIM copy attempts and regular RPC connections
                                            if (!$RemoteKB){
                                                $null = (& robocopy "$Copy\$($PatchObj.Build)" "\\$Comp\C$\Windows\Temp\$($PatchObj.KB)" $Patch /S /MT:50 /r:30 /w:05 2>&1)
                                            }
                                            else {
                                                $MediaExists = $true
                                            }
                                        }
                                        catch {
                                            "$Comp : Failed to copy $Patch to device - $($_.Exception.Message)" | Out-File -FilePath $ResultFile -Append -Force
                                        }
                                        finally {
                                            if ($CIMConnects){$null = Remove-PSSession -Session $CopySession -ErrorAction SilentlyContinue}
                                        }
                                        $CopyLocation = $Copy
                                    } # if (!$RemoteKB){
                                    else {
                                        $MediaExists = $true
                                    } 
                                } # foreach ($PatchObj in $AllRequiredPatches){

                                #Final Check
                                foreach ($PatchObj in $AllRequiredPatches){
                                    $Patch = $PatchObj.MSUFile
                                    $KBRemoteDir = "C:\Windows\Temp\$($PatchObj.KB)"
                                    $KBRemotePath = "$KBRemoteDir\$Patch"
                                    $KBRemotePathWMI = $KBRemotePath.replace('\','\\')

                                    #Run the final check
                                    $RemoteKB = (Get-WSMWMIQuery -ComputerName $Comp -WinRM $WinRM -Query "SELECT * FROM CIM_DataFile WHERE Name = `'$KBRemotePathWMI`'").Result
                                    if (!$RemoteKB){
                                        $MediaExists = $false
                                        "$Comp : Patch $Patch not located on device - $KBRemotePath" | Out-File -FilePath $ResultFile -Append -Force
                                    }
                                    else {
                                        "$Comp : Patch $Patch located on device - $KBRemotePath" | Out-File -FilePath $ResultFile -Append -Force
                                    }
                                } # foreach ($PatchObj in $AllRequiredPatches){

                                #Search for remaining psexec procs and kill... at some point...

                            } # if (!$MediaExists){
                            #endregion - copy the files

                        } # if ($MissingKBs -and ($Vulnerability -ne 'Patched')){
                    #endregion - Copy files to local device

                    #region - Run the update

                    try {

                        [array]$InstalledKBs = @()

                        #If WinRM connected
                        if ($CIMConnects){
                            $RunMethod = 'WinRM'

                        #region - install patch
                            "$Comp : About to enter WinRM patching section. AttemptPatch = $AttemptPatch. MediaExists = $MediaExists" | Out-File -FilePath $ResultFile -Append -Force
                            if ($AttemptPatch -and $MediaExists){

                                "$Comp : Patch is still needed and install media is located on remote device" | Out-File -FilePath $ResultFile -Append -Force
                                foreach ($Patch in ($AllRequiredPatches | Sort-Object -Property InstallPriority -Descending)){

                                    "$Comp : Working on $($Patch.KB)" | Out-File -FilePath $ResultFile -Append -Force
                                    
                                    if ($Reboot -ne $true){
                                        $KBFile = $Patch.MSUFile
                                        $KBNum = $Patch.KB
                                        $Cab = $Patch.CabFile
                                        "$Comp : No pending reboot. Moving to Patch block" | Out-File -FilePath $ResultFile -Append -Force

                                        $PatchBlock = {
                                            Param($KBNum,$KBFile,$Wus,$Cab)
                                            $TrySchedtask = $false
                                            $File2Copy = $KBFile
                                            $KB = $KBNum

                                            [array]$ExitError = @()

                                            #$ExtractedCab = (Get-ChildItem -Path "C:\Windows\Temp\$KB" -filter '*.cab' | Where-Object {$_.BaseName -match $File2Copy}).fullname
                                            #if (!$ExtractedCab){
                                            $ExtractedCab = "C:\Windows\Temp\$KB\$Cab"
                                            if (!(Test-Path -Path $ExtractedCab -ErrorAction SilentlyContinue)){
                                                $RunProcess = Start-Process -FilePath 'expand' -ArgumentList "-f:* C:\Windows\Temp\$KB\$File2Copy C:\Windows\Temp\$KB\" -passthru
                                                $RunProcess | Wait-Process -Timeout 300 -ErrorAction SilentlyContinue
                                            }

                                            #Install the patch
                                            try {

                                                if ( !($KBInstallCheck = Get-HotFix -Id $KB -ErrorAction SilentlyContinue) ){
                                                    $DISMProc = Start-Process -FilePath 'dism.exe' -ArgumentList "/online /add-package /PackagePath:$ExtractedCab /Quiet /NoRestart" -PassThru
                                                    $DISMProc | Wait-Process -Timeout 600 -ErrorAction SilentlyContinue
                                                } # if ( !($KBInstallCheck = Get-HotFix -Id $KB -ErrorAction SilentlyContinue) ){

                                                ###########This is where I whacked a proprietary reboot key

                                            } # try {
                                            catch {$ExitError += $_.Exception.Message}

                                            #Return
                                            If (!$KBInstallCheck){
                                                $KBInstallCheck = Get-HotFix -Id $KB -ErrorAction SilentlyContinue
                                            }
                                            elseif ($ExitError){$ExitError}
    
                                        } # $PatchBlock = {

                                        #Run the patchblock
                                        $InstallKB = Invoke-Command -ComputerName $Comp -ScriptBlock $PatchBlock -ArgumentList $KBNum,$KBFile,$Wus,$Cab
                                        
                                        "$Comp : Script Block return: $InstallKB" | Out-File -FilePath $ResultFile -Append -Force

                                        $CheckForRebootFlag = Invoke-Command -ComputerName $Comp -ScriptBlock {
                                            $CompSvc = Test-Path -path "HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\Component Based Servicing\RebootPending" -ea SilentlyContinue
                                            $WinSxSXml = Test-Path -path "$env:WINDIR\winsxs\pending.xml" -ea SilentlyContinue
                                            $WinUpdate = Test-Path -path 'HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\WindowsUpdate\Auto Update\RebootRequired'
                                            if ($CompSvc -or $WinSxSXml -or $WinUpdate){'1'}else{'0'}
                                        }

                                        #Main targeted KB must be installed after a reboot.
                                        if (($Patch.Reboot -eq $true)-or ($CheckForRebootFlag -eq '1')){$Reboot = $true}

                                        if ($InstallKB.HotFixID){
                                            #I don't want any other garbage that might follow back up the pipeline
                                            $InstalledKBs += [string]$InstallKB.HotFixID
                                        }
                                        else {
                                            $OSIssue = $true
                                        }
                                    } # if ($Reboot -eq $false){
                                } # foreach ($Patch in ($AllRequiredPatches | Sort-Object -Property InstallPriority -Descending)){
                            } # if ($AttemptPatch -and $MediaExists){
                            elseif ($AttemptPatch -and !$MediaExists){
                                "$Comp : Script determined that the patch is needed but the media was not copied to the remote device. Exiting..." | Out-File -FilePath $ResultFile -Append -Force
                            }
                            elseif (!$AttemptPatch){
                                "$Comp : Script determined that the patch is not needed. Exiting..." | Out-File -FilePath $ResultFile -Append -Force
                            }

                        $FullKBList = (Get-WSMWMIQuery -ComputerName $Comp -WinRM $WinRM -Class 'Win32_QuickFixEngineering').Result
                        #We only really care about the main patches being installed.
                        $KBInspection = ($FullKBList.HotFixID).where({$_ -in $MainPatchObjs.kb})
                        if ( $KBInspection.count -eq ($MainPatchObjs.kb).count ){
                            "$Comp : Post install attempt using WINRM shows the patch to be installed." | Out-File -FilePath $ResultFile -Append -Force
                            $Vulnerability = 'Patched'
                        }

                        #endregion - Install patch

                        } # if ($CIMConnects){
                        elseif ($WMIConnects){
                            $RunMethod = 'RPC'

                            #region - install patch

                                "$Comp : About to enter RPC patching section. AttemptPatch = $AttemptPatch. MediaExists = $MediaExists" | Out-File -FilePath $ResultFile -Append -Force
                                if ($AttemptPatch -and $MediaExists){

                                    "$Comp : Patch exists and install media is on remote device" | Out-File -FilePath $ResultFile -Append -Force
                                    foreach ($Patch in ($AllRequiredPatches | Sort-Object -Property InstallPriority -Descending)){

                                        $KBFile = $Patch.MSUFile
                                        $KBNum = $Patch.KB
                                        $Cab = $Patch.CabFile

                                        "$Comp : About to begin installing patch $KBNum." | Out-File -FilePath $ResultFile -Append -Force

                                        if (!$Reboot){
                                            $ExtractCommand = "expand -f:* C:\Windows\Temp\$KBNum\$KBFile C:\Windows\Temp\$KBNum\"
                                            $DISMInstall = "DISM.exe /online /add-package /PackagePath:C:\Windows\Temp\$KBNum\$Cab /Quiet /NoRestart"

                                            foreach ($try in 1..10){
                                                if ($proc = Invoke-WmiMethod -ComputerName $Comp -Class Win32_Process -Name Create -ArgumentList "cmd.exe /c $ExtractCommand" -ErrorAction Stop){
                                                    Start-Sleep -Seconds 320
                                                    break
                                                }
                                                Start-Sleep -Seconds 2
                                            }

                                            foreach ($try in 1..10){
                                                if ($proc = Invoke-WmiMethod -ComputerName $Comp -Class Win32_Process -Name Create -ArgumentList "cmd.exe /c $DISMInstall" -ErrorAction Stop){
                                                    Start-Sleep -Seconds 600
                                                    break
                                                }
                                                Start-Sleep -Seconds 2
                                            }

                                            # either RPC or Reg only would work here
                                            $WinSxSXmlPath = "C:\\winsxs\\pending.xml"
                                            $WinSxSXml = (Get-WSMWMIQuery -ComputerName $Comp -WinRM $WinRM -Query "SELECT * FROM Win32_Directory WHERE Name = `'$WinSxSXmlPath`'").Result
                                            $CompSvc = (& reg query "\\$Comp\HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Component Based Servicing\RebootPending" /v OSDComputerName 2>&1).Where({$_ -notmatch 'ERROR:'})
                                            $WinUpdate = (& reg query "\\$Comp\HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\WindowsUpdate\Auto Update\RebootRequired" /v OSDComputerName 2>&1).Where({$_ -notmatch 'ERROR:'})
                                            if ($CompSvc -or $WinSxSXml -or $WinUpdate){$CheckForRebootFlag = '1'}else{$CheckForRebootFlag = '0'}

                                            #Main targeted KB must be installed after a reboot.
                                            if (($CheckForRebootFlag -eq '1') -or ($Patch.Reboot -eq $true)){$Reboot = $true}

                                        } # if (!$Reboot){

                                    } # foreach ($Patch in ($AllRequiredPatches | Sort-Object -Property InstallPriority -Descending)){

                                    $FullKBList = (Get-WSMWMIQuery -ComputerName $Comp -WinRM $WinRM -Class 'Win32_QuickFixEngineering').Result
                                    #We only really care about the main patches being installed.
                                    $KBInspection = ($FullKBList.HotFixID).where({$_ -in $MainPatchObjs.kb})
                                    if ( $KBInspection.count -eq ($MainPatchObjs.kb).count ){
                                        "$Comp : Post install attempt using WMI (RPC) shows the patch to be installed." | Out-File -FilePath $ResultFile -Append -Force 
                                        $Vulnerability = 'Patched'
                                    }

                                } # if ($AttemptPatch -and $MediaExists){
                            
                            #endregion - install patch

                        } # elseif ($WMIConnects){
                        #Else this is if we're left with psexec...if that even works...
                        else {
                        #Likely WinRM is disabled and RPC is being blocked.
                            $RunMethod = 'PSExec'
                            "$Comp : About to enter PSExec patching section. AttemptPatch = $AttemptPatch. MediaExists = $MediaExists" | Out-File -FilePath $ResultFile -Append -Force
                            
                            #region - install patch
                                if ($AttemptPatch -and $MediaExists){

                                    "$Comp : Patch exists and install media is on remote device" | Out-File -FilePath $ResultFile -Append -Force
                                    foreach ($Patch in ($AllRequiredPatches | Sort-Object -Property InstallPriority -Descending)){

                                        "$Comp : About to begin installing patch $KBNum." | Out-File -FilePath $ResultFile -Append -Force

                                        $KBFile = $Patch.MSUFile
                                        $KBNum = $Patch.KB
                                        $Cab = $Patch.CabFile

                                        $ExtractCommand = "expand -f:* C:\Windows\Temp\$KBNum\$KBFile C:\Windows\Temp\$KBNum\"
                                        $DISMInstall = "DISM.exe /online /add-package /PackagePath:C:\Windows\Temp\$KBNum\$Cab /Quiet /NoRestart"

                                        #Extract the MSU
                                        $ExtractArgs = "-accepteula -s \\$Comp "
                                        $ExtractArgs += $ExtractCommand

                                        $ExtractProc = Start-Process -FilePath $psexec -ArgumentList $ExtractArgs -passthru -ea Stop
                                        $ExtractProc | Wait-Process -Timeout -Timeout 320 -ErrorAction Stop

                                        #Install the MSU
                                        $DISMArgs = "-accepteula -s \\$Comp "
                                        $DISMArgs += $DISMInstall

                                        $DISMProc = Start-Process -FilePath $psexec -ArgumentList $DISMArgs -passthru -ea Stop
                                        $DISMProc | Wait-Process -Timeout -Timeout 600 -ErrorAction Stop

                                        # either RPC or Reg only would work here
                                        $CompSvc = (& reg query "\\$Comp\HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Component Based Servicing\RebootPending" /v OSDComputerName 2>&1).Where({$_ -notmatch 'ERROR:'})
                                        $WinUpdate = (& reg query "\\$Comp\HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\WindowsUpdate\Auto Update\RebootRequired" /v OSDComputerName 2>&1).Where({$_ -notmatch 'ERROR:'})
                                        if ($CompSvc -or $WinUpdate){$CheckForRebootFlag = '1'}else{$CheckForRebootFlag = '0'}

                                        #Main targeted KB must be installed after a reboot.
                                        if (($CheckForRebootFlag -eq '1') -or ($Patch.Reboot -eq $true)){$Reboot = $true}

                                    } # foreach ($Patch in ($AllRequiredPatches | Sort-Object -Property InstallPriority -Descending)){
                                } # if ($AttemptPatch -and $MediaExists){

                                try {
                                    $RegQuery = & reg query "\\$Comp\HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Component Based Servicing\Packages"
                                    $KBInspection = (($RegQuery | Where-Object {$_ -match $KBCheck} | 
                                        ForEach-Object {(Split-Path $_ -Leaf -ErrorAction SilentlyContinue)} ).foreach({($_.split('_'))[-1].split('~')[0]})) | 
                                            Select-Object -Unique
                                    if ($KBInspection.count -eq ($MainPatchObjs.kb).count){
                                        "$Comp The KB Count when checked by the registry counts the device as being patched." | Out-File -FilePath $ResultFile -Append -Force 
                                        $Vulnerability = 'Patched'
                                    }
                                }
                                catch {
                                    "Had issue querying if a registry key existed." | Out-File -FilePath $ResultFile -Append -Force
                                }
                            #endregion - install patch
                        } # else {

                    }
                    catch {
                        Write-Warning -Message "$($Comp):Error - Starting patch installation process: $Proc"
                        "$($Comp):Error - Starting patch installation process: $($_.Exception.Message)" | Out-File -FilePath $ResultFile -Append -Force
                    }

                    #endregion - Run the update
                }#if (($OkayToProceed -eq $true) -and ($Access -eq $true)){
                
            }#if (Test-Connection -ComputerName $Comp -Count 3 -ErrorAction SilentlyContinue){
            else {
                Write-Warning -Message "$($Comp):Could not contact device!"
                "$($Comp):Error - Could not contact device!" | Out-File -FilePath $ResultFile -Append -Force
                $Access = $false
                $CIMConnects = $false
                $WMIConnects = $false
                $Vulnerability = 'Unknown'
                $RegName = 'Unknown'
                $WMIName = 'Unknown'
            }

            #Just doing this because otherwise it's bleeding on the screen a bit and it bothers me.
            if ($DeviceIP){
                $DeviceIP = $DeviceIP[0].IPV4Address.IPAddressToString
            } else {$DeviceIP = '?.?.?.?'}

            #Just doing this because otherwise it's bleeding on the screen a bit and it bothers me.
            if ($Error){
                #$DaErrorz = $Error.Exception.message
                $DaErrorz = $Error.Exception.message
            } else {$DaErrorz = 'None'} 

            if ($DeletePreviousKB -or $RemoveRebootCheck -or $RemTask -or $SchTaskKill){<#Quite the script analyzer#>}

            #I am unsaticified with the returns off thei script so I am going to attempt to get a report on any instsalled KBs here and of course slow the process a bit more.
            #region - Check for the KBs again
                if ($AttemptPatch -and ($InstalledKBs -in '',$null) ){
                    $InstalledKBs = Get-HotFix -ComputerName $([string]$Comp) -Id $MainPatchObjs.KB -ErrorAction SilentlyContinue
                }

                if ($AttemptPatch -and ($InstalledPrereqs -in '',$null) ){
                    $InstalledPrereqs = Get-HotFix -ComputerName $([string]$Comp) -Id $PreReqs.KB -ErrorAction SilentlyContinue
                }
            #endregion - Check for the KBs again

            [pscustomobject]@{
                ComputerName = [string]$Comp
                Job = $JobName
                ListedIP =  $DeviceIP
                WMIDeviceName = $WMIName
                RegDeviceName = $RegName
                NameCheck = $NameCheck
                ADObject = $AD_Record
                FreeDiskSpace = $PreFreeSpace
                DiskCleanupAttempted = $CleanupAttempt
                OperatingSystem = $OSName
                HasAccess = [bool]$Access
                WMIConnection = $WMIConnects
                WMIHealth = $WMIInfo
                WinRMConnection = $CIMConnects
                WinRMHealth = $CIMInfo
                VDIStatus = [string]$VDISkip
                SafeToModify = $OkayToProceed
                RunMethod = $RunMethod
                KBCheck = $KBInspection
                InstalledPreReqs = $Satisfied_PreReqs
                ScriptInstalledKBs = $InstalledKBs
                ScriptInstalledPreReqs = $InstalledPrereqs
                MediaAvailable = $MediaExists
                MissingPrereqs = $MissingPrereqs.KB
                Attempt2Patch = $AttemptPatch
                SourcedFrom = $CopyLocation
                Vulnerability = $Vulnerability
                RebootBeforeFinalPatch = $Reboot
                PrePatchRDPFileVersion = $PatchFileCheck.version
                HasSolidCore = [string]$SolidCorePresent
                PushRestricted = [string]$PushRestricted
                NotAcceptingPatch = $OSIssue
                lastError = $DaErrorz
                RunspaceID = $RunspaceID
            }

            [System.GC]::Collect()

    }#ScriptBlock block

    #for each job in the list we'll start jobs, up to the max allowed, then wait
    #for some to stop running, then start more until we're out of jobs to start
    Write-Verbose -Message "Starting job: $JobName"
    if ($LogFile){Write-WSMLogMessage -Message "$Section Starting job: $JobName" -LogFile $LogFile}

    Start-Job -Name $JobName -ScriptBlock $ScriptBlock

    #While the queue is full, we'll sleep 1/4 second and then recheck for open queue slots
    while ((Get-Job -Name $JobName | Where-Object {$_.State -match 'Running'}).Count -ge $MaxConcurrentJobs){
        Start-Sleep -Milliseconds 250

        #We'll look at all the current jobs and if any of them have been running
        #for longer than the max allocated time, we'll put them into a stopped
        #state (collect the data later) so we don't get hung up with a full queue
        Get-Job -Name $JobName | Where-Object {$_.State -match 'Running'} | ForEach-Object {
            if ((Get-Date) -gt (Get-Date ($_.PSBeginTime)).AddHours($MaxRunHours)){
                Write-Verbose -Message 'Stopping Job...'
                Stop-Job $_
                [System.GC]::Collect()
            }
        }#foreach get-job that runs over time
    }#while

    # Receive any completed jobs
    Get-Job -Name $JobName | ForEach-Object {
        #If the state is completed, we'll "Receive" the job to collect the exit data.
        #If it's in any other state, we'll spoof the data, then force remove the job.
        if ($_.State -match 'Completed'){
            #Receive the job to collect it's output data
            $Output += Receive-Job $_ -Verbose

            Write-Verbose -Message "Receiving job: $($_.Name)"
            if ($LogFile){Write-WSMLogMessage -Message "$Section Receiving job: $($_.Name)" -LogFile $LogFile}

            #Remove the job. At the end of the loop all jobs should be cleared
            Remove-Job $_ -Force -Verbose
        }
        }#foreach Get-Job
    
    }# if ($AdInspection = $Domain | Where-Object {$_.Name -Match $Comp}){
        else {"$Comp : No Valid AD Record" | Out-File -FilePath $PostOutFile -Append -Force }

    }#foreach

# Allow any remaining jobs to complete and collect their data
#While there are any jobs in the 'Running' state, and the expiration time has not elapsed, sleep for 1/4 second and check again
while ((Get-Job -Name $JobName -ErrorAction SilentlyContinue | Where-Object {$_.State -ne 'Stopped'}).Count -gt 0){
    #We'll look at all the current jobs and if any of them have been running
    #for longer than the max allocated time, we'll put them into a stopped
    #state (collect the data later) so we don't get hung up with a full queue
    Get-Job -Name $JobName | Where-Object {$_.State -match 'Running'} | ForEach-Object {
        if ((Get-Date) -gt (Get-Date ($_.PSBeginTime)).AddHours($MaxRunHours)){
            Write-Verbose -Message 'Stopping Job...'
            Stop-Job $_ -Verbose
            [System.GC]::Collect()
        }
    }#foreach get-job that runs over time

    # Receive any completed jobs
    Get-Job -Name $JobName | ForEach-Object {
        #If the state is completed, we'll "Receive" the job to collect the exit data.
        #If it's in any other state, we'll spoof the data, then force remove the job.
        if ($_.State -match 'Completed'){
            #Receive the job to collect it's output data
            $Output += Receive-Job $_ -Verbose

            Write-Verbose -Message "Receiving job: $($_.Name)"
            if ($LogFile){Write-WSMLogMessage -Message "$Section Receiving job: $($_.Name)" -LogFile $LogFile}

            #Remove the job. At the end of the loop all jobs should be cleared
            Remove-Job $_ -Force -Verbose
        }
    }#foreach Get-Job

    # Do a little sleep before we cycle again to releive the processor
    Start-Sleep -Milliseconds 250
}#while

# Ones that didn't get done before
$Remaining += $PCList | Where-Object {$_ -notin $Output.ComputerName}

$Output | Out-File -FilePath $PostOutFile -Append -Force

$Output | ConvertTo-Json | Out-File -FilePath $PostOutJson -Append -Force

$Output | ConvertTo-Csv -Delimiter "`t" | Out-File -FilePath $PostOutCSV -Append -Force

#Stop-Transcript
